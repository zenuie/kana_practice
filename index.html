<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è½éŸ³å¯«å­—ç‰¹è¨“ç­</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- ONNX Runtime -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

    <style>
        body {
            font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", sans-serif;
            background-color: #f4f7f6;
            touch-action: manipulation; /* é˜²æ­¢æ‰‹æ©Ÿæ»‘å‹• */
            user-select: none; /* é˜²æ­¢é¸å–æ–‡å­— */
        }

        /* é ‚éƒ¨å°è¦½ */
        .top-bar {
            background: white;
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* ä¸»å¡ç‰‡ */
        .learning-card {
            background: white;
            border-radius: 24px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            max-width: 400px;
            margin: 20px auto;
            position: relative;
        }

        /* é¡Œç›®å€ (è²éŸ³èˆ‡æç¤º) */
        .question-area {
            padding: 20px;
            text-align: center;
            background: #e3f2fd;
            position: relative;
        }

        .speaker-btn {
            width: 90px;
            height: 90px;
            background: #2196f3;
            border-radius: 50%;
            color: white;
            font-size: 40px;
            border: none;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
            transition: transform 0.1s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .speaker-btn:active {
            transform: scale(0.95);
        }

        .hint-text {
            font-size: 6rem;
            font-weight: bold;
            color: #1565c0;
            display: none; /* é è¨­éš±è— */
            animation: fadeIn 0.3s;
        }

        .romaji-hint {
            font-size: 1.2rem;
            color: #666;
            margin-top: 10px;
            display: none;
        }

        /* ç•«å¸ƒå€ */
        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            background: #fff;
            cursor: crosshair;
            border-top: 2px dashed #e0e0e0;
            border-bottom: 2px dashed #e0e0e0;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* è¼”åŠ©æ ¼ç·š (ç”°å­—æ ¼) */
        .grid-line {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.05);
            pointer-events: none;
        }

        .grid-h {
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
        }

        .grid-v {
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
        }

        /* æ§åˆ¶å€ */
        .controls {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn-action {
            padding: 15px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            border: none;
            transition: all 0.2s;
        }

        .btn-check {
            background: #4caf50;
            color: white;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .btn-check:active {
            transform: translateY(2px);
        }

        .tools-row {
            display: flex;
            gap: 10px;
        }

        .btn-tool {
            flex: 1;
            background: #f5f5f5;
            color: #555;
        }

        /* çµæœå›é¥‹è¦†è“‹å±¤ */
        .feedback-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            z-index: 10;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            animation: slideUp 0.3s ease-out;
        }

        .result-icon {
            font-size: 80px;
            margin-bottom: 10px;
        }

        .result-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .result-desc {
            color: #666;
            margin-bottom: 20px;
        }

        /* æ”¶é›†æ¨£æœ¬æŒ‰éˆ• (é‡è¦) */
        .btn-save-sample {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
            font-size: 0.9rem;
            padding: 8px 15px;
            border-radius: 20px;
            margin-top: 15px;
            cursor: pointer;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>

<div class="top-bar">
    <div class="fw-bold text-primary">ğŸŒ è½å¯«ç‰¹è¨“</div>
    <div class="d-flex gap-2 align-items-center">
        <span id="statusBadge" class="badge bg-secondary">è¼‰å…¥ AI ä¸­...</span>
        <span class="badge bg-light text-dark border">é€£å°: <span id="streakCount">0</span></span>
    </div>
</div>

<div class="learning-card">

    <!-- 1. é¡Œç›®å€ -->
    <div class="question-area">
        <!-- æ’­æ”¾æŒ‰éˆ• (é è¨­é¡¯ç¤º) -->
        <button class="speaker-btn" id="btnPlay" onclick="app.playAudio()">ğŸ”Š</button>

        <!-- æç¤ºé¡¯ç¤º (é è¨­éš±è—) -->
        <div id="visualHint" class="hint-text">ã‚</div>
        <div id="romajiHint" class="romaji-hint">a</div>

        <div class="mt-3">
            <button class="btn btn-sm btn-link text-decoration-none" onclick="app.toggleHint()">ğŸ’¡ å·çœ‹æç¤º</button>
        </div>
    </div>

    <!-- 2. å¯«å­—æ¿ -->
    <div class="canvas-container">
        <div class="grid-line grid-h"></div>
        <div class="grid-line grid-v"></div>
        <canvas id="drawingBoard"></canvas>
    </div>

    <!-- 3. æ“ä½œæŒ‰éˆ• -->
    <div class="controls">
        <button class="btn-action btn-check" onclick="app.checkAnswer()">âœ¨ æª¢æŸ¥ç­”æ¡ˆ</button>
        <div class="tools-row">
            <button class="btn-action btn-tool" onclick="sketch.clear()">ğŸ—‘ï¸ æ¸…é™¤</button>
            <button class="btn-action btn-tool" onclick="app.nextQuestion()">â© è·³é</button>
        </div>
    </div>

    <!-- 4. çµæœå›é¥‹ (AI åˆ¤è®€å¾Œé¡¯ç¤º) -->
    <div id="feedbackOverlay" class="feedback-overlay">
        <div id="fbIcon" class="result-icon">ğŸ‰</div>
        <div id="fbTitle" class="result-title">ç­”å°äº†ï¼</div>
        <div id="fbDesc" class="result-desc">AI çœ‹åˆ°ï¼šã‚ (99%)</div>

        <div class="d-grid gap-2 w-75">
            <button class="btn btn-primary btn-lg rounded-pill shadow" onclick="app.nextQuestion()">ä¸‹ä¸€é¡Œ â”</button>

            <div class="border-top pt-3 mt-2">
                <small class="text-muted d-block mb-2">AI åˆ¤æ–·éŒ¯äº†å—ï¼Ÿ</small>
                <button class="btn btn-outline-danger btn-sm w-100" onclick="app.markAsWrong()">âŒ å…¶å¯¦æˆ‘å¯«éŒ¯äº†</button>
                <button class="btn btn-outline-success btn-sm w-100 mt-2" onclick="app.forceCorrect()">â­• å…¶å¯¦æˆ‘æ˜¯å°çš„ (å­˜æ¨£æœ¬)</button>
            </div>
        </div>
    </div>

    <!-- éš±è—çš„ Debug ç•«å¸ƒ (çµ¦ ONNX ç”¨) -->
    <canvas id="debugCanvas" width="64" height="64" style="display:none;"></canvas>
</div>

<script>
    // é¡Œåº«
    const KANA_DB = [
        {r: 'a', h: 'ã‚'}, {r: 'i', h: 'ã„'}, {r: 'u', h: 'ã†'}, {r: 'e', h: 'ãˆ'}, {r: 'o', h: 'ãŠ'},
        {r: 'ka', h: 'ã‹'}, {r: 'ki', h: 'ã'}, {r: 'ku', h: 'ã'}, {r: 'ke', h: 'ã‘'}, {r: 'ko', h: 'ã“'},
        {r: 'sa', h: 'ã•'}, {r: 'shi', h: 'ã—'}, {r: 'su', h: 'ã™'}, {r: 'se', h: 'ã›'}, {r: 'so', h: 'ã'},
        {r: 'ta', h: 'ãŸ'}, {r: 'chi', h: 'ã¡'}, {r: 'tsu', h: 'ã¤'}, {r: 'te', h: 'ã¦'}, {r: 'to', h: 'ã¨'},
        {r: 'na', h: 'ãª'}, {r: 'ni', h: 'ã«'}, {r: 'nu', h: 'ã¬'}, {r: 'ne', h: 'ã­'}, {r: 'no', h: 'ã®'},
        {r: 'ha', h: 'ã¯'}, {r: 'hi', h: 'ã²'}, {r: 'fu', h: 'ãµ'}, {r: 'he', h: 'ã¸'}, {r: 'ho', h: 'ã»'},
        {r: 'ma', h: 'ã¾'}, {r: 'mi', h: 'ã¿'}, {r: 'mu', h: 'ã‚€'}, {r: 'me', h: 'ã‚'}, {r: 'mo', h: 'ã‚‚'},
        {r: 'ya', h: 'ã‚„'}, {r: 'yu', h: 'ã‚†'}, {r: 'yo', h: 'ã‚ˆ'},
        {r: 'ra', h: 'ã‚‰'}, {r: 'ri', h: 'ã‚Š'}, {r: 'ru', h: 'ã‚‹'}, {r: 're', h: 'ã‚Œ'}, {r: 'ro', h: 'ã‚'},
        {r: 'wa', h: 'ã‚'}, {r: 'wo', h: 'ã‚’'}, {r: 'n', h: 'ã‚“'}
    ];

    let MODEL_LABELS = [];

    const app = {
        session: null,
        currentQ: null,
        streak: 0,
        autoCheckTimer: null, // è‡ªå‹•æª¢æŸ¥è¨ˆæ™‚å™¨

        init: async function () {
            sketch.init();

            // é å…ˆè¼‰å…¥ç€è¦½å™¨è²éŸ³åˆ—è¡¨ (è§£æ±º Chrome æœ‰æ™‚æŠ“ä¸åˆ°è²éŸ³çš„å•é¡Œ)
            window.speechSynthesis.getVoices();
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = () => window.speechSynthesis.getVoices();
            }

            await this.loadLabels();
            await this.initAI();
            this.nextQuestion();
        },

        loadLabels: async function () {
            try {
                const res = await fetch('./data/labels.json');
                if (res.ok) MODEL_LABELS = await res.json();
            } catch (e) {
                console.warn("Labels error", e);
            }
        },

        initAI: async function () {
            try {
                const option = {executionProviders: ['wasm']};
                this.session = await ort.InferenceSession.create('./onnx_model/hiragana.onnx', option);
                document.getElementById('statusBadge').className = 'badge bg-success';
                document.getElementById('statusBadge').innerText = 'AI å°±ç·’';
            } catch (e) {
                console.error(e);
                document.getElementById('statusBadge').className = 'badge bg-danger';
                document.getElementById('statusBadge').innerText = 'AI è¼‰å…¥å¤±æ•—';
                alert("éŒ¯èª¤ï¼šæ‰¾ä¸åˆ° onnx_model/hiragana.onnxï¼Œè«‹ç¢ºèªæª”æ¡ˆä½ç½®ï¼");
            }
        },

        nextQuestion: function () {
            document.getElementById('feedbackOverlay').style.display = 'none';
            this.currentQ = KANA_DB[Math.floor(Math.random() * KANA_DB.length)];

            document.getElementById('visualHint').style.display = 'none';
            document.getElementById('visualHint').innerText = this.currentQ.h;
            document.getElementById('romajiHint').style.display = 'none';
            document.getElementById('romajiHint').innerText = this.currentQ.r;
            document.getElementById('btnPlay').style.display = 'inline-flex';

            sketch.clear();
            setTimeout(() => this.playAudio(), 300);
        },

        playAudio: function () {
            if (!this.currentQ) return;
            const char = this.currentQ.h;

            // æ–¹æ¡ˆ A: ä½¿ç”¨ Google é«˜å“è³ª TTS (éœ€è¦ç¶²è·¯)
            // client=tw-ob æ˜¯ Google çš„å…¬é–‹ TTS æ¥å£ï¼Œè²éŸ³éå¸¸æ¨™æº–
            const url = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=ja&q=${char}`;
            const audio = new Audio(url);

            // è¨­å®šæ’­æ”¾é€Ÿåº¦ (Google TTS é è¨­èªé€Ÿé©ä¸­ï¼Œé€šå¸¸ä¸éœ€è¦èª¿)
            audio.playbackRate = 1.0;

            // å˜—è©¦æ’­æ”¾
            audio.play().catch((e) => {
                console.warn("Google Audio æ’­æ”¾å¤±æ•— (å¯èƒ½ç„¡ç¶²è·¯)ï¼Œåˆ‡æ›å›å…§å»ºèªéŸ³", e);
                this.playFallbackAudio(char);
            });
        },

        // æ–¹æ¡ˆ B: ç€è¦½å™¨å…§å»ºèªéŸ³ (é›¢ç·šå‚™ç”¨)
        playFallbackAudio: function (text) {
            window.speechSynthesis.cancel(); // å…ˆåœæ­¢ä¸Šä¸€å¥
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'ja-JP';
            u.rate = 0.8; // ç¨å¾®æ”¾æ…¢ï¼Œè®“åˆå­¸è€…è½æ¸…æ¥šå…ƒéŸ³

            // å˜—è©¦æŒ‘é¸æ¯”è¼ƒå¥½è½çš„è²éŸ³ (é‡å° Windows/Mac å„ªåŒ–)
            const voices = window.speechSynthesis.getVoices();
            // å„ªå…ˆæ‰¾ Google çš„æ—¥æ–‡ï¼Œå…¶æ¬¡æ‰¾ Apple çš„ Kyoko/Otoyaï¼Œæœ€å¾Œæ‰¾å¾®è»Ÿ
            const preferredVoice = voices.find(v => v.name.includes("Google æ—¥æœ¬èª")) ||
                voices.find(v => v.name.includes("Kyoko")) ||
                voices.find(v => v.name.includes("Otoya")) ||
                voices.find(v => v.name.includes("Haruka")) ||
                voices.find(v => v.lang === 'ja-JP');

            if (preferredVoice) {
                u.voice = preferredVoice;
                // å¦‚æœæ˜¯ Google è²éŸ³ï¼Œèªé€Ÿå¯ä»¥æ­£å¸¸é»ï¼›å¦‚æœæ˜¯å¾®è»Ÿæ©Ÿæ¢°éŸ³ï¼Œæ…¢ä¸€é»æ¯”è¼ƒå¥½
                if (preferredVoice.name.includes("Microsoft")) u.rate = 0.7;
            }

            window.speechSynthesis.speak(u);
        },

        toggleHint: function () {
            const h = document.getElementById('visualHint');
            const r = document.getElementById('romajiHint');
            const btn = document.getElementById('btnPlay');

            if (h.style.display === 'none') {
                h.style.display = 'block';
                r.style.display = 'block';
                btn.style.display = 'none';
            } else {
                h.style.display = 'none';
                r.style.display = 'none';
                btn.style.display = 'inline-flex';
            }
        },

        // â˜…â˜…â˜… æ–°å¢ï¼šé–‹å§‹è‡ªå‹•æª¢æŸ¥å€’æ•¸ â˜…â˜…â˜…
        startAutoCheck: function () {
            // å¦‚æœå·²ç¶“æœ‰åœ¨å€’æ•¸ï¼Œå…ˆå–æ¶ˆï¼Œé‡æ–°è¨ˆæ™‚ (é˜²æŠ–å‹• Debounce)
            if (this.autoCheckTimer) clearTimeout(this.autoCheckTimer);

            // è¨­å®š 1.2 ç§’å¾Œè‡ªå‹•é€å‡º
            this.autoCheckTimer = setTimeout(() => {
                // åªæœ‰åœ¨é‚„æ²’é¡¯ç¤ºçµæœæ™‚æ‰æª¢æŸ¥
                if (document.getElementById('feedbackOverlay').style.display === 'none') {
                    this.checkAnswer();
                }
            }, 1200);
        },

        // â˜…â˜…â˜… æ–°å¢ï¼šå–æ¶ˆè‡ªå‹•æª¢æŸ¥ (ç•¶ä½¿ç”¨è€…åˆé–‹å§‹å¯«å­—æ™‚) â˜…â˜…â˜…
        cancelAutoCheck: function () {
            if (this.autoCheckTimer) {
                clearTimeout(this.autoCheckTimer);
                this.autoCheckTimer = null;
            }
        },

        checkAnswer: async function () {
            if (!this.session) return;
            if (sketch.isEmpty()) return; // ç©ºç™½ä¸æª¢æŸ¥

            const canvas = document.getElementById('drawingBoard');
            const inputTensor = this.processCanvasForONNX(canvas);

            if (!inputTensor) return;

            try {
                const feeds = {input: inputTensor};
                const results = await this.session.run(feeds);
                const outputData = results.output.data;

                let maxVal = -Infinity;
                let maxIdx = -1;
                for (let i = 0; i < outputData.length; i++) {
                    if (outputData[i] > maxVal) {
                        maxVal = outputData[i];
                        maxIdx = i;
                    }
                }

                const aiChar = MODEL_LABELS[maxIdx];
                const mapFix = {"ta": "ãŸ", "te": "ã¦", "ha": "ã¯", "he": "ã¸", "ho": "ã»"};
                const displayChar = mapFix[aiChar] || aiChar;

                this.showFeedback(displayChar, maxVal);

            } catch (e) {
                console.error(e);
            }
        },

        showFeedback: function (aiChar, confidence) {
            const overlay = document.getElementById('feedbackOverlay');
            const icon = document.getElementById('fbIcon');
            const title = document.getElementById('fbTitle');
            const desc = document.getElementById('fbDesc');

            overlay.style.display = 'flex';

            if (aiChar === this.currentQ.h) {
                icon.innerText = 'ğŸ‰';
                title.innerText = 'ç­”å°äº†ï¼';
                title.style.color = '#2e7d32';
                desc.innerText = `AI çœ‹åˆ°ï¼š${aiChar} (${confidence.toFixed(1)})`;
                this.streak++;
            } else {
                icon.innerText = 'ğŸ¤”';
                title.innerText = 'å—¯...ä¸å¤ªåƒï¼Ÿ';
                title.style.color = '#c62828';
                desc.innerText = `é¡Œç›®æ˜¯ã€Œ${this.currentQ.h}ã€ï¼ŒAI çœ‹åˆ°ã€Œ${aiChar}ã€`;
                this.streak = 0;
            }

            document.getElementById('streakCount').innerText = this.streak;
        },

        forceCorrect: function () {
            this.downloadSample();
            this.streak++;
            document.getElementById('streakCount').innerText = this.streak;
            document.getElementById('fbTitle').innerText = "å·²å›å ±æ¨£æœ¬ï¼";
            setTimeout(() => this.nextQuestion(), 800);
        },

        markAsWrong: function () {
            this.streak = 0;
            document.getElementById('streakCount').innerText = 0;
            this.nextQuestion();
        },

        downloadSample: function () {
            const canvas = document.getElementById('drawingBoard');
            const processed = processCanvasForAI(canvas, 64);
            if (processed) {
                const label = this.currentQ.r;
                const link = document.createElement('a');
                link.download = `${label}_${Date.now()}.png`;
                link.href = processed.toDataURL();
                link.click();
            }
        },

        processCanvasForONNX: function (sourceCanvas) {
            const processedCanvas = processCanvasForAI(sourceCanvas, 64);
            if (!processedCanvas) return null;

            const ctx = processedCanvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, 64, 64);
            const {data} = imgData;
            const floatData = new Float32Array(3 * 64 * 64);

            for (let i = 0; i < 64 * 64; i++) {
                const r = data[i * 4] / 255.0;
                floatData[i] = r;
                floatData[64 * 64 + i] = r;
                floatData[2 * 64 * 64 + i] = r;
            }
            return new ort.Tensor('float32', floatData, [1, 3, 64, 64]);
        }
    };

    function processCanvasForAI(sourceCanvas, targetSize = 64) {
        const ctx = sourceCanvas.getContext('2d');
        const width = sourceCanvas.width;
        const height = sourceCanvas.height;
        const imgData = ctx.getImageData(0, 0, width, height);
        const data = imgData.data;

        let minX = width, minY = height, maxX = 0, maxY = 0, found = false;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (data[(y * width + x) * 4] < 250) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    found = true;
                }
            }
        }
        if (!found) return null;

        const cropW = maxX - minX;
        const cropH = maxY - minY;
        const finalC = document.createElement('canvas');
        finalC.width = targetSize;
        finalC.height = targetSize;
        const fCtx = finalC.getContext('2d');
        fCtx.fillStyle = "black";
        fCtx.fillRect(0, 0, targetSize, targetSize);

        const pad = 6;
        const scale = Math.min((targetSize - pad * 2) / cropW, (targetSize - pad * 2) / cropH);
        const sw = cropW * scale;
        const sh = cropH * scale;
        const dx = (targetSize - sw) / 2;
        const dy = (targetSize - sh) / 2;

        const tempC = document.createElement('canvas');
        tempC.width = cropW;
        tempC.height = cropH;
        tempC.getContext('2d').drawImage(sourceCanvas, minX, minY, cropW, cropH, 0, 0, cropW, cropH);

        fCtx.filter = 'invert(1)';
        fCtx.drawImage(tempC, 0, 0, cropW, cropH, dx, dy, sw, sh);
        fCtx.filter = 'none';

        const idata = fCtx.getImageData(0, 0, targetSize, targetSize);
        const d = idata.data;
        for (let i = 0; i < d.length; i += 4) {
            const v = d[i] > 80 ? 255 : 0;
            d[i] = v;
            d[i + 1] = v;
            d[i + 2] = v;
        }
        fCtx.putImageData(idata, 0, 0);
        return finalC;
    }

    const sketch = {
        init: function () {
            this.c = document.getElementById('drawingBoard');
            this.ctx = this.c.getContext('2d', {willReadFrequently: true});
            const wrapper = this.c.parentElement;
            this.c.width = wrapper.clientWidth;
            this.c.height = wrapper.clientHeight;
            this.clear();

            const start = (e) => {
                e.preventDefault();
                this.draw = true;
                this.ctx.beginPath();
                const p = this.pos(e);
                this.ctx.moveTo(p.x, p.y);

                // â˜…â˜…â˜… é–‹å§‹å¯«å­—æ™‚ï¼Œå–æ¶ˆè‡ªå‹•æª¢æŸ¥
                app.cancelAutoCheck();
            };

            const move = (e) => {
                e.preventDefault();
                if (this.draw) {
                    const p = this.pos(e);
                    this.ctx.lineTo(p.x, p.y);
                    this.ctx.stroke();
                }
            };

            const end = () => {
                this.draw = false;
                // â˜…â˜…â˜… åœç­†å¾Œï¼Œå•Ÿå‹•è‡ªå‹•æª¢æŸ¥
                app.startAutoCheck();
            };

            this.c.addEventListener('mousedown', start);
            this.c.addEventListener('mousemove', move);
            this.c.addEventListener('mouseup', end);
            this.c.addEventListener('touchstart', start, {passive: false});
            this.c.addEventListener('touchmove', move, {passive: false});
            this.c.addEventListener('touchend', end);

            window.addEventListener('resize', () => {
                this.c.width = wrapper.clientWidth;
                this.c.height = wrapper.clientHeight;
                this.clear();
            });
        },
        pos: function (e) {
            const r = this.c.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {x: clientX - r.left, y: clientY - r.top};
        },
        clear: function () {
            this.ctx.fillStyle = "white";
            this.ctx.fillRect(0, 0, this.c.width, this.c.height);
            this.ctx.lineWidth = 15;
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.strokeStyle = 'black';
            app.cancelAutoCheck(); // æ¸…é™¤æ™‚ä¹Ÿå–æ¶ˆè¨ˆæ™‚
        },
        isEmpty: function () {
            const d = this.ctx.getImageData(0, 0, this.c.width, this.c.height).data;
            for (let i = 0; i < d.length; i += 4) if (d[i] < 255) return false;
            return true;
        }
    };

    document.addEventListener("DOMContentLoaded", () => app.init());
</script>
</body>
</html>