<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è½å¯«ç‰¹è¨“</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

    <style>
        body {
            font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", sans-serif;
            background-color: #f4f7f6;
            touch-action: manipulation;
            user-select: none;
            overflow: hidden;
        }

        /* å•Ÿå‹•é®ç½© (è²éŸ³è§£é–) */
        #startOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.98); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center;
        }

        /* åœ–ç‰‡å„²å­˜å½ˆçª— (åƒ…æ‰‹æ©Ÿé¡¯ç¤º) */
        #saveModal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 10000;
            display: none; /* é è¨­éš±è— */
            flex-direction: column; justify-content: center; align-items: center;
        }
        #saveModal img {
            background: white; border-radius: 16px; max-width: 80%;
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }

        .top-bar {
            background: white; padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: flex; justify-content: space-between; align-items: center;
        }

        .learning-card {
            background: white; border-radius: 24px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            overflow: hidden; max-width: 400px; margin: 20px auto;
            position: relative;
        }

        .question-area {
            padding: 20px; text-align: center; background: #e3f2fd; position: relative;
        }

        .speaker-btn {
            width: 90px; height: 90px; background: #2196f3;
            border-radius: 50%; color: white; font-size: 40px;
            border: none; box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
            transition: transform 0.1s; display: inline-flex;
            align-items: center; justify-content: center; cursor: pointer;
        }
        .speaker-btn:active { transform: scale(0.95); }

        .hint-text {
            font-size: 6rem; font-weight: bold; color: #1565c0;
            display: none; animation: fadeIn 0.3s;
        }
        .romaji-hint {
            font-size: 1.2rem; color: #666; margin-top: 10px; display: none;
        }

        .canvas-container {
            position: relative; width: 100%; aspect-ratio: 1; background: #fff;
            cursor: crosshair; border-top: 2px dashed #e0e0e0; border-bottom: 2px dashed #e0e0e0;
        }
        canvas { width: 100%; height: 100%; display: block; }

        .grid-line { position: absolute; background-color: rgba(0, 0, 0, 0.05); pointer-events: none; }
        .grid-h { top: 50%; left: 0; right: 0; height: 1px; }
        .grid-v { left: 50%; top: 0; bottom: 0; width: 1px; }

        .controls { padding: 20px; display: flex; flex-direction: column; gap: 10px; }

        .btn-action { padding: 15px; border-radius: 12px; font-size: 1.1rem; font-weight: bold; border: none; transition: all 0.2s; }
        .btn-check { background: #4caf50; color: white; box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3); }
        .btn-check:active { transform: translateY(2px); }

        .tools-row { display: flex; gap: 10px; }
        .btn-tool { flex: 1; background: #f5f5f5; color: #555; }

        .feedback-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.95); z-index: 10;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; animation: slideUp 0.3s ease-out;
        }

        .result-icon { font-size: 80px; margin-bottom: 10px; }
        .result-title { font-size: 24px; font-weight: bold; margin-bottom: 5px; }
        .result-desc { color: #666; margin-bottom: 20px; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body>

<!-- å•Ÿå‹•é é¢ -->
<div id="startOverlay">
    <div class="mb-4" style="font-size: 3rem;">ğŸŒ</div>
    <h1 class="mb-4 text-primary fw-bold">è½å¯«ç‰¹è¨“</h1>
    <div class="px-4">
        <p class="text-muted mb-4">è«‹é–‹å•ŸéŸ³é‡ï¼Œé»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å§‹</p>
        <button class="btn btn-primary btn-lg px-5 py-3 rounded-pill shadow fw-bold" onclick="app.unlockAudio()">
            â–¶ï¸ é–‹å§‹ç·´ç¿’
        </button>
    </div>
</div>

<!-- åœ–ç‰‡å„²å­˜å½ˆçª— (åƒ…åœ¨æ‰‹æ©Ÿ/å¹³æ¿å‡ºç¾) -->
<div id="saveModal" onclick="this.style.display='none'">
    <h3 id="saveHintText" class="text-white mb-3">é•·æŒ‰åœ–ç‰‡åŠ å…¥ç…§ç‰‡</h3>
    <img id="saveImageDisplay" src="" alt="Sample">
    <p class="text-white-50 mt-3 small">é»æ“Šä»»æ„è™•é—œé–‰</p>
</div>

<div class="top-bar">
    <div class="fw-bold text-primary">ğŸŒ è½å¯«ç‰¹è¨“</div>
    <div class="d-flex gap-2 align-items-center">
        <span id="statusBadge" class="badge bg-secondary">è¼‰å…¥ AI...</span>
        <span class="badge bg-light text-dark border">é€£å°: <span id="streakCount">0</span></span>
    </div>
</div>

<div class="learning-card">
    <div class="question-area">
        <button class="speaker-btn" id="btnPlay" onclick="app.playAudio()">ğŸ”Š</button>
        <div id="visualHint" class="hint-text">ã‚</div>
        <div id="romajiHint" class="romaji-hint">a</div>
        <div class="mt-3">
            <button class="btn btn-sm btn-link text-decoration-none" onclick="app.toggleHint()">ğŸ’¡ å·çœ‹æç¤º</button>
        </div>
    </div>

    <div class="canvas-container">
        <div class="grid-line grid-h"></div>
        <div class="grid-line grid-v"></div>
        <canvas id="drawingBoard"></canvas>
    </div>

    <div class="controls">
        <button class="btn-action btn-check" onclick="app.checkAnswer()">âœ¨ æª¢æŸ¥ç­”æ¡ˆ</button>
        <div class="tools-row">
            <button class="btn-action btn-tool" onclick="sketch.clear()">ğŸ—‘ï¸ æ¸…é™¤</button>
            <button class="btn-action btn-tool" onclick="app.nextQuestion()">â© è·³é</button>
        </div>
    </div>

    <div id="feedbackOverlay" class="feedback-overlay">
        <div id="fbIcon" class="result-icon">ğŸ‰</div>
        <div id="fbTitle" class="result-title">ç­”å°äº†ï¼</div>
        <div id="fbDesc" class="result-desc">AI çœ‹åˆ°ï¼šã‚ (99%)</div>

        <div class="d-grid gap-2 w-75">
            <button class="btn btn-primary btn-lg rounded-pill shadow" onclick="app.nextQuestion()">ä¸‹ä¸€é¡Œ â”</button>
            <div class="border-top pt-3 mt-2">
                <small class="text-muted d-block mb-2">AI åˆ¤æ–·éŒ¯äº†å—ï¼Ÿ</small>
                <button class="btn btn-outline-danger btn-sm w-100" onclick="app.markAsWrong()">âŒ å…¶å¯¦æˆ‘å¯«éŒ¯äº†</button>
                <button class="btn btn-outline-success btn-sm w-100 mt-2" onclick="app.forceCorrect()">â­• å…¶å¯¦æˆ‘æ˜¯å°çš„ (å­˜åœ–)</button>
            </div>
        </div>
    </div>
</div>

<script>
    const KANA_DB = [
        {r: 'a', h: 'ã‚'}, {r: 'i', h: 'ã„'}, {r: 'u', h: 'ã†'}, {r: 'e', h: 'ãˆ'}, {r: 'o', h: 'ãŠ'},
        {r: 'ka', h: 'ã‹'}, {r: 'ki', h: 'ã'}, {r: 'ku', h: 'ã'}, {r: 'ke', h: 'ã‘'}, {r: 'ko', h: 'ã“'},
        {r: 'sa', h: 'ã•'}, {r: 'shi', h: 'ã—'}, {r: 'su', h: 'ã™'}, {r: 'se', h: 'ã›'}, {r: 'so', h: 'ã'},
        {r: 'ta', h: 'ãŸ'}, {r: 'chi', h: 'ã¡'}, {r: 'tsu', h: 'ã¤'}, {r: 'te', h: 'ã¦'}, {r: 'to', h: 'ã¨'},
        {r: 'na', h: 'ãª'}, {r: 'ni', h: 'ã«'}, {r: 'nu', h: 'ã¬'}, {r: 'ne', h: 'ã­'}, {r: 'no', h: 'ã®'},
        {r: 'ha', h: 'ã¯'}, {r: 'hi', h: 'ã²'}, {r: 'fu', h: 'ãµ'}, {r: 'he', h: 'ã¸'}, {r: 'ho', h: 'ã»'},
        {r: 'ma', h: 'ã¾'}, {r: 'mi', h: 'ã¿'}, {r: 'mu', h: 'ã‚€'}, {r: 'me', h: 'ã‚'}, {r: 'mo', h: 'ã‚‚'},
        {r: 'ya', h: 'ã‚„'}, {r: 'yu', h: 'ã‚†'}, {r: 'yo', h: 'ã‚ˆ'},
        {r: 'ra', h: 'ã‚‰'}, {r: 'ri', h: 'ã‚Š'}, {r: 'ru', h: 'ã‚‹'}, {r: 're', h: 'ã‚Œ'}, {r: 'ro', h: 'ã‚'},
        {r: 'wa', h: 'ã‚'}, {r: 'wo', h: 'ã‚’'}, {r: 'n', h: 'ã‚“'}
    ];

    let MODEL_LABELS = [];

    const app = {
        session: null,
        currentQ: null,
        streak: 0,
        autoCheckTimer: null,
        isAudioUnlocked: false,

        init: async function () {
            sketch.init();
            if ('speechSynthesis' in window) {
                window.speechSynthesis.getVoices();
            }
            await this.loadLabels();
            await this.initAI();
        },

        unlockAudio: function() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                osc.connect(ctx.destination);
                osc.start(0);
                osc.stop(0.01);
            }
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const u = new SpeechSynthesisUtterance('');
                window.speechSynthesis.speak(u);
            }
            this.isAudioUnlocked = true;
            document.getElementById('startOverlay').style.display = 'none';
            this.nextQuestion();
        },

        loadLabels: async function () {
            try {
                const res = await fetch('./data/labels.json');
                if (res.ok) MODEL_LABELS = await res.json();
            } catch (e) { console.warn("Labels error", e); }
        },

        initAI: async function () {
            try {
                const option = {executionProviders: ['wasm']};
                this.session = await ort.InferenceSession.create('./onnx_model/hiragana.onnx', option);
                document.getElementById('statusBadge').className = 'badge bg-success';
                document.getElementById('statusBadge').innerText = 'AI å°±ç·’';
            } catch (e) {
                console.error(e);
                document.getElementById('statusBadge').className = 'badge bg-danger';
                document.getElementById('statusBadge').innerText = 'AI è¼‰å…¥å¤±æ•—';
            }
        },

        nextQuestion: function () {
            document.getElementById('feedbackOverlay').style.display = 'none';
            this.currentQ = KANA_DB[Math.floor(Math.random() * KANA_DB.length)];

            document.getElementById('visualHint').style.display = 'none';
            document.getElementById('visualHint').innerText = this.currentQ.h;
            document.getElementById('romajiHint').style.display = 'none';
            document.getElementById('romajiHint').innerText = this.currentQ.r;
            document.getElementById('btnPlay').style.display = 'inline-flex';

            sketch.clear();
            if (this.isAudioUnlocked) {
                setTimeout(() => this.playAudio(), 500);
            }
        },

        // é«˜éŸ³è³ªç™¼éŸ³ + å‚™ç”¨
        playAudio: function () {
            if (!this.currentQ) return;
            const char = this.currentQ.h;
            // ä½¿ç”¨ Google é«˜å“è³ª TTS
            const audioUrl = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=ja&q=${encodeURIComponent(char)}`;
            const audio = new Audio(audioUrl);
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.warn("TTS Error, fallback", error);
                    this.playFallbackAudio(char);
                });
            }
        },

        playFallbackAudio: function (text) {
            if (!('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'ja-JP';
            u.rate = 0.8;
            const voices = window.speechSynthesis.getVoices();
            const preferredVoice =
                voices.find(v => v.lang === 'ja-JP' && v.name.includes("Kyoko")) ||
                voices.find(v => v.lang === 'ja-JP' && v.name.includes("Otoya")) ||
                voices.find(v => v.lang === 'ja-JP');
            if (preferredVoice) u.voice = preferredVoice;
            window.speechSynthesis.speak(u);
            if (window.speechSynthesis.paused) window.speechSynthesis.resume();
        },

        toggleHint: function () {
            const h = document.getElementById('visualHint');
            const r = document.getElementById('romajiHint');
            const btn = document.getElementById('btnPlay');
            const isHidden = h.style.display === 'none';
            h.style.display = isHidden ? 'block' : 'none';
            r.style.display = isHidden ? 'block' : 'none';
            btn.style.display = isHidden ? 'none' : 'inline-flex';
        },

        startAutoCheck: function () {
            if (this.autoCheckTimer) clearTimeout(this.autoCheckTimer);
            this.autoCheckTimer = setTimeout(() => {
                if (document.getElementById('feedbackOverlay').style.display === 'none') {
                    this.checkAnswer();
                }
            }, 1200);
        },

        cancelAutoCheck: function () {
            if (this.autoCheckTimer) {
                clearTimeout(this.autoCheckTimer);
                this.autoCheckTimer = null;
            }
        },

        checkAnswer: async function () {
            if (!this.session || sketch.isEmpty()) return;

            const canvas = document.getElementById('drawingBoard');
            const inputTensor = this.processCanvasForONNX(canvas);
            if (!inputTensor) return;

            try {
                const feeds = {input: inputTensor};
                const results = await this.session.run(feeds);
                const outputData = results.output.data;

                let maxVal = -Infinity;
                let maxIdx = -1;
                for (let i = 0; i < outputData.length; i++) {
                    if (outputData[i] > maxVal) {
                        maxVal = outputData[i];
                        maxIdx = i;
                    }
                }

                const aiChar = MODEL_LABELS[maxIdx];
                const mapFix = {"ta": "ãŸ", "te": "ã¦", "ha": "ã¯", "he": "ã¸", "ho": "ã»"};
                const displayChar = mapFix[aiChar] || aiChar;
                this.showFeedback(displayChar, maxVal);

            } catch (e) { console.error(e); }
        },

        showFeedback: function (aiChar, confidence) {
            const overlay = document.getElementById('feedbackOverlay');
            const icon = document.getElementById('fbIcon');
            const title = document.getElementById('fbTitle');
            const desc = document.getElementById('fbDesc');
            overlay.style.display = 'flex';
            if (aiChar === this.currentQ.h) {
                icon.innerText = 'ğŸ‰';
                title.innerText = 'ç­”å°äº†ï¼';
                title.style.color = '#2e7d32';
                desc.innerText = `AI çœ‹åˆ°ï¼š${aiChar} (${confidence.toFixed(1)})`;
                this.streak++;
                setTimeout(() => this.playAudio(), 200);
            } else {
                icon.innerText = 'ğŸ¤”';
                title.innerText = 'å—¯...ä¸å¤ªåƒï¼Ÿ';
                title.style.color = '#c62828';
                desc.innerText = `é¡Œç›®æ˜¯ã€Œ${this.currentQ.h}ã€ï¼ŒAI çœ‹åˆ°ã€Œ${aiChar}ã€`;
                this.streak = 0;
            }
            document.getElementById('streakCount').innerText = this.streak;
        },

        // â˜…â˜…â˜… æ ¸å¿ƒä¿®æ”¹ï¼šå€åˆ†é›»è…¦èˆ‡æ‰‹æ©Ÿçš„å„²å­˜é‚è¼¯ â˜…â˜…â˜…
        forceCorrect: function () {
            this.handleSaveAction(); // å‘¼å«æ–°çš„å„²å­˜è™•ç†å‡½å¼
            this.streak++;
            document.getElementById('streakCount').innerText = this.streak;
            document.getElementById('fbTitle').innerText = "å·²å›å ±ï¼";
            setTimeout(() => this.nextQuestion(), 1500);
        },

        markAsWrong: function () {
            this.streak = 0;
            document.getElementById('streakCount').innerText = 0;
            this.nextQuestion();
        },

        // æ–°å¢ï¼šè™•ç†å„²å­˜é‚è¼¯ (å€åˆ† Mobile/Desktop)
        handleSaveAction: function() {
            const canvas = document.getElementById('drawingBoard');
            const processed = processCanvasForAI(canvas, 64);
            if (!processed) return;

            const dataUrl = processed.toDataURL("image/png");

            // ç°¡æ˜“çš„ Mobile è£ç½®åµæ¸¬ (åŒ…å« iPhone, Android ç­‰)
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                // å¦‚æœæ˜¯æ‰‹æ©Ÿ -> é¡¯ç¤ºå½ˆçª—
                const modal = document.getElementById('saveModal');
                const img = document.getElementById('saveImageDisplay');
                img.src = dataUrl;
                modal.style.display = 'flex';
            } else {
                // å¦‚æœæ˜¯é›»è…¦ -> ç›´æ¥è§¸ç™¼ä¸‹è¼‰
                const link = document.createElement('a');
                link.download = `${this.currentQ.r}_${Date.now()}.png`;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        },

        processCanvasForONNX: function (sourceCanvas) {
            const processedCanvas = processCanvasForAI(sourceCanvas, 64);
            if (!processedCanvas) return null;
            const ctx = processedCanvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, 64, 64);
            const {data} = imgData;
            const floatData = new Float32Array(3 * 64 * 64);
            for (let i = 0; i < 64 * 64; i++) {
                const r = data[i * 4] / 255.0;
                floatData[i] = r;
                floatData[64 * 64 + i] = r;
                floatData[2 * 64 * 64 + i] = r;
            }
            return new ort.Tensor('float32', floatData, [1, 3, 64, 64]);
        }
    };

    function processCanvasForAI(sourceCanvas, targetSize = 64) {
        const ctx = sourceCanvas.getContext('2d');
        const width = sourceCanvas.width;
        const height = sourceCanvas.height;
        const imgData = ctx.getImageData(0, 0, width, height);
        const data = imgData.data;
        let minX = width, minY = height, maxX = 0, maxY = 0, found = false;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (data[(y * width + x) * 4] < 250) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    found = true;
                }
            }
        }
        if (!found) return null;
        const cropW = maxX - minX;
        const cropH = maxY - minY;
        const finalC = document.createElement('canvas');
        finalC.width = targetSize;
        finalC.height = targetSize;
        const fCtx = finalC.getContext('2d');
        fCtx.fillStyle = "black";
        fCtx.fillRect(0, 0, targetSize, targetSize);
        const pad = 6;
        const scale = Math.min((targetSize - pad * 2) / cropW, (targetSize - pad * 2) / cropH);
        const sw = cropW * scale;
        const sh = cropH * scale;
        const dx = (targetSize - sw) / 2;
        const dy = (targetSize - sh) / 2;
        const tempC = document.createElement('canvas');
        tempC.width = cropW;
        tempC.height = cropH;
        tempC.getContext('2d').drawImage(sourceCanvas, minX, minY, cropW, cropH, 0, 0, cropW, cropH);
        fCtx.filter = 'invert(1)';
        fCtx.drawImage(tempC, 0, 0, cropW, cropH, dx, dy, sw, sh);
        fCtx.filter = 'none';
        const idata = fCtx.getImageData(0, 0, targetSize, targetSize);
        const d = idata.data;
        for (let i = 0; i < d.length; i += 4) {
            const v = d[i] > 80 ? 255 : 0;
            d[i] = v;
            d[i + 1] = v;
            d[i + 2] = v;
        }
        fCtx.putImageData(idata, 0, 0);
        return finalC;
    }

    const sketch = {
        init: function () {
            this.c = document.getElementById('drawingBoard');
            this.ctx = this.c.getContext('2d', {willReadFrequently: true});
            const wrapper = this.c.parentElement;
            this.c.width = wrapper.clientWidth;
            this.c.height = wrapper.clientHeight;
            this.clear();
            const start = (e) => {
                if (e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                this.draw = true;
                this.ctx.beginPath();
                const p = this.pos(e);
                this.ctx.moveTo(p.x, p.y);
                app.cancelAutoCheck();
            };
            const move = (e) => {
                if (e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                if (this.draw) {
                    const p = this.pos(e);
                    this.ctx.lineTo(p.x, p.y);
                    this.ctx.stroke();
                }
            };
            const end = () => {
                this.draw = false;
                app.startAutoCheck();
            };
            this.c.addEventListener('mousedown', start);
            this.c.addEventListener('mousemove', move);
            this.c.addEventListener('mouseup', end);
            this.c.addEventListener('touchstart', start, {passive: false});
            this.c.addEventListener('touchmove', move, {passive: false});
            this.c.addEventListener('touchend', end);
            window.addEventListener('resize', () => {
                this.c.width = wrapper.clientWidth;
                this.c.height = wrapper.clientHeight;
                this.clear();
            });
        },
        pos: function (e) {
            const r = this.c.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {x: clientX - r.left, y: clientY - r.top};
        },
        clear: function () {
            this.ctx.fillStyle = "white";
            this.ctx.fillRect(0, 0, this.c.width, this.c.height);
            this.ctx.lineWidth = 15;
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.strokeStyle = 'black';
            app.cancelAutoCheck();
        },
        isEmpty: function () {
            const d = this.ctx.getImageData(0, 0, this.c.width, this.c.height).data;
            for (let i = 0; i < d.length; i += 4) if (d[i] < 255) return false;
            return true;
        }
    };

    document.addEventListener("DOMContentLoaded", () => app.init());
</script>
</body>
</html>