<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è½å¯«ç‰¹è¨“</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

    <style>
        body {
            font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", sans-serif;
            background-color: #f4f7f6;
            touch-action: manipulation;
            user-select: none;
            overflow: hidden;
        }

        #startOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.98); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center;
        }

        #saveModal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 10000;
            display: none;
            flex-direction: column; justify-content: center; align-items: center;
        }
        #saveModal img {
            background: #333; /* èƒŒæ™¯æ”¹æ·±è‰²ä»¥ä¾¿è§€å¯Ÿç™½å­— */
            border: 2px solid #fff;
            border-radius: 16px;
            width: 200px; height: 200px; /* å¼·åˆ¶é¡¯ç¤ºå¤§å° */
            image-rendering: pixelated; /* è®“åƒç´ æ¸…æ™° */
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }

        .top-bar {
            background: white; padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: flex; justify-content: space-between; align-items: center;
        }

        .learning-card {
            background: white; border-radius: 24px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            overflow: hidden; max-width: 400px; margin: 20px auto;
            position: relative;
        }

        .question-area {
            padding: 20px; text-align: center; background: #e3f2fd; position: relative;
        }

        .speaker-btn {
            width: 90px; height: 90px; background: #2196f3;
            border-radius: 50%; color: white; font-size: 40px;
            border: none; box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
            transition: transform 0.1s; display: inline-flex;
            align-items: center; justify-content: center; cursor: pointer;
        }
        .speaker-btn:active { transform: scale(0.95); }

        .hint-text {
            font-size: 6rem; font-weight: bold; color: #1565c0;
            display: none; animation: fadeIn 0.3s;
        }
        .romaji-hint {
            font-size: 1.2rem; color: #666; margin-top: 10px; display: none;
        }

        /* å¼·åˆ¶ç•«å¸ƒå®¹å™¨ç‚ºæ­£æ–¹å½¢ */
        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1; /* ç¾ä»£ç€è¦½å™¨å¼·åˆ¶æ­£æ–¹å½¢ */
            background: #fff;
            cursor: crosshair;
            border-top: 2px dashed #e0e0e0;
            border-bottom: 2px dashed #e0e0e0;
        }
        canvas { width: 100%; height: 100%; display: block; }

        .grid-line { position: absolute; background-color: rgba(0, 0, 0, 0.05); pointer-events: none; }
        .grid-h { top: 50%; left: 0; right: 0; height: 1px; }
        .grid-v { left: 50%; top: 0; bottom: 0; width: 1px; }

        .controls { padding: 20px; display: flex; flex-direction: column; gap: 10px; }

        .btn-action { padding: 15px; border-radius: 12px; font-size: 1.1rem; font-weight: bold; border: none; transition: all 0.2s; }
        .btn-check { background: #4caf50; color: white; box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3); }
        .btn-check:active { transform: translateY(2px); }

        .tools-row { display: flex; gap: 10px; }
        .btn-tool { flex: 1; background: #f5f5f5; color: #555; }

        .feedback-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.95); z-index: 10;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; animation: slideUp 0.3s ease-out;
        }

        .result-icon { font-size: 80px; margin-bottom: 10px; }
        .result-title { font-size: 24px; font-weight: bold; margin-bottom: 5px; }
        .result-desc { color: #666; margin-bottom: 20px; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body>

<div id="startOverlay">
    <div class="mb-4" style="font-size: 3rem;">ğŸŒ</div>
    <h1 class="mb-4 text-primary fw-bold">è½å¯«ç‰¹è¨“</h1>
    <div class="px-4">
        <p class="text-muted mb-4">è«‹é–‹å•ŸéŸ³é‡ï¼Œé»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å§‹</p>
        <button class="btn btn-primary btn-lg px-5 py-3 rounded-pill shadow fw-bold" onclick="app.unlockAudio()">
            â–¶ï¸ é–‹å§‹ç·´ç¿’
        </button>
    </div>
</div>

<!-- åœ–ç‰‡å„²å­˜å½ˆçª— -->
<div id="saveModal" onclick="this.style.display='none'">
    <h3 id="saveHintText" class="text-white mb-3">é•·æŒ‰åœ–ç‰‡åŠ å…¥ç…§ç‰‡</h3>
    <!-- é€™è£¡é¡¯ç¤ºçš„æœƒæ˜¯ AI çœ‹åˆ°çš„çœŸæ­£æ¨£å­ (é»‘åº•ç™½å­—) -->
    <img id="saveImageDisplay" src="" alt="Sample">
    <p class="text-white-50 mt-3 small">é€™æ˜¯ AI çœ‹åˆ°çš„å½±åƒ (64x64)</p>
</div>

<div class="top-bar">
    <div class="fw-bold text-primary">ğŸŒ è½å¯«ç‰¹è¨“</div>
    <div class="d-flex gap-2 align-items-center">
        <span id="statusBadge" class="badge bg-secondary">è¼‰å…¥ AI...</span>
        <span class="badge bg-light text-dark border">é€£å°: <span id="streakCount">0</span></span>
    </div>
</div>

<div class="learning-card">
    <div class="question-area">
        <button class="speaker-btn" id="btnPlay" onclick="app.playAudio()">ğŸ”Š</button>
        <div id="visualHint" class="hint-text">ã‚</div>
        <div id="romajiHint" class="romaji-hint">a</div>
        <div class="mt-3">
            <button class="btn btn-sm btn-link text-decoration-none" onclick="app.toggleHint()">ğŸ’¡ å·çœ‹æç¤º</button>
        </div>
    </div>

    <div class="canvas-container">
        <div class="grid-line grid-h"></div>
        <div class="grid-line grid-v"></div>
        <canvas id="drawingBoard"></canvas>
    </div>

    <div class="controls">
        <button class="btn-action btn-check" onclick="app.checkAnswer()">âœ¨ æª¢æŸ¥ç­”æ¡ˆ</button>
        <div class="tools-row">
            <button class="btn-action btn-tool" onclick="sketch.clear()">ğŸ—‘ï¸ æ¸…é™¤</button>
            <button class="btn-action btn-tool" onclick="app.nextQuestion()">â© è·³é</button>
        </div>
    </div>

    <div id="feedbackOverlay" class="feedback-overlay">
        <div id="fbIcon" class="result-icon">ğŸ‰</div>
        <div id="fbTitle" class="result-title">ç­”å°äº†ï¼</div>
        <div id="fbDesc" class="result-desc">AI çœ‹åˆ°ï¼šã‚ (99%)</div>

        <div class="d-grid gap-2 w-75">
            <button class="btn btn-primary btn-lg rounded-pill shadow" onclick="app.nextQuestion()">ä¸‹ä¸€é¡Œ â”</button>
            <div class="border-top pt-3 mt-2">
                <small class="text-muted d-block mb-2">AI åˆ¤æ–·éŒ¯äº†å—ï¼Ÿ</small>
                <button class="btn btn-outline-danger btn-sm w-100" onclick="app.markAsWrong()">âŒ å…¶å¯¦æˆ‘å¯«éŒ¯äº†</button>
                <button class="btn btn-outline-success btn-sm w-100 mt-2" onclick="app.forceCorrect()">â­• å…¶å¯¦æˆ‘æ˜¯å°çš„ (å­˜æ¨£æœ¬)</button>
            </div>
        </div>
    </div>
</div>

<script>
    // é¡Œåº«
    const KANA_DB = [
        {r: 'a', h: 'ã‚'}, {r: 'i', h: 'ã„'}, {r: 'u', h: 'ã†'}, {r: 'e', h: 'ãˆ'}, {r: 'o', h: 'ãŠ'},
        {r: 'ka', h: 'ã‹'}, {r: 'ki', h: 'ã'}, {r: 'ku', h: 'ã'}, {r: 'ke', h: 'ã‘'}, {r: 'ko', h: 'ã“'},
        {r: 'sa', h: 'ã•'}, {r: 'shi', h: 'ã—'}, {r: 'su', h: 'ã™'}, {r: 'se', h: 'ã›'}, {r: 'so', h: 'ã'},
        {r: 'ta', h: 'ãŸ'}, {r: 'chi', h: 'ã¡'}, {r: 'tsu', h: 'ã¤'}, {r: 'te', h: 'ã¦'}, {r: 'to', h: 'ã¨'},
        {r: 'na', h: 'ãª'}, {r: 'ni', h: 'ã«'}, {r: 'nu', h: 'ã¬'}, {r: 'ne', h: 'ã­'}, {r: 'no', h: 'ã®'},
        {r: 'ha', h: 'ã¯'}, {r: 'hi', h: 'ã²'}, {r: 'fu', h: 'ãµ'}, {r: 'he', h: 'ã¸'}, {r: 'ho', h: 'ã»'},
        {r: 'ma', h: 'ã¾'}, {r: 'mi', h: 'ã¿'}, {r: 'mu', h: 'ã‚€'}, {r: 'me', h: 'ã‚'}, {r: 'mo', h: 'ã‚‚'},
        {r: 'ya', h: 'ã‚„'}, {r: 'yu', h: 'ã‚†'}, {r: 'yo', h: 'ã‚ˆ'},
        {r: 'ra', h: 'ã‚‰'}, {r: 'ri', h: 'ã‚Š'}, {r: 'ru', h: 'ã‚‹'}, {r: 're', h: 'ã‚Œ'}, {r: 'ro', h: 'ã‚'},
        {r: 'wa', h: 'ã‚'}, {r: 'wo', h: 'ã‚’'}, {r: 'n', h: 'ã‚“'}
    ];

    let MODEL_LABELS = [];

    const app = {
        session: null,
        currentQ: null,
        streak: 0,
        autoCheckTimer: null,
        isAudioUnlocked: false,

        init: async function () {
            sketch.init();
            if ('speechSynthesis' in window) window.speechSynthesis.getVoices();
            await this.loadLabels();
            await this.initAI();
        },

        unlockAudio: function() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                osc.connect(ctx.destination);
                osc.start(0);
                osc.stop(0.01);
            }
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const u = new SpeechSynthesisUtterance('');
                window.speechSynthesis.speak(u);
            }
            this.isAudioUnlocked = true;
            document.getElementById('startOverlay').style.display = 'none';
            this.nextQuestion();
        },

        loadLabels: async function () {
            try {
                const res = await fetch('./data/labels.json');
                if (res.ok) MODEL_LABELS = await res.json();
            } catch (e) { console.warn("Labels error", e); }
        },

        initAI: async function () {
            try {
                const option = {executionProviders: ['wasm']};
                this.session = await ort.InferenceSession.create('./onnx_model/hiragana.onnx', option);
                document.getElementById('statusBadge').className = 'badge bg-success';
                document.getElementById('statusBadge').innerText = 'AI å°±ç·’';
            } catch (e) {
                console.error(e);
                document.getElementById('statusBadge').className = 'badge bg-danger';
                document.getElementById('statusBadge').innerText = 'AI è¼‰å…¥å¤±æ•—';
            }
        },

        nextQuestion: function () {
            document.getElementById('feedbackOverlay').style.display = 'none';
            this.currentQ = KANA_DB[Math.floor(Math.random() * KANA_DB.length)];
            document.getElementById('visualHint').style.display = 'none';
            document.getElementById('visualHint').innerText = this.currentQ.h;
            document.getElementById('romajiHint').style.display = 'none';
            document.getElementById('romajiHint').innerText = this.currentQ.r;
            document.getElementById('btnPlay').style.display = 'inline-flex';
            sketch.clear();
            if (this.isAudioUnlocked) setTimeout(() => this.playAudio(), 500);
        },

        playAudio: function () {
            if (!this.currentQ) return;
            const char = this.currentQ.h;
            const audioUrl = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=ja&q=${encodeURIComponent(char)}`;
            const audio = new Audio(audioUrl);
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.warn("Fallback TTS", error);
                    this.playFallbackAudio(char);
                });
            }
        },

        playFallbackAudio: function (text) {
            if (!('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'ja-JP';
            u.rate = 0.8;
            const voices = window.speechSynthesis.getVoices();
            const preferredVoice = voices.find(v => v.lang === 'ja-JP' && (v.name.includes("Kyoko") || v.name.includes("Otoya")));
            if (preferredVoice) u.voice = preferredVoice;
            window.speechSynthesis.speak(u);
            if (window.speechSynthesis.paused) window.speechSynthesis.resume();
        },

        toggleHint: function () {
            const h = document.getElementById('visualHint');
            const r = document.getElementById('romajiHint');
            const btn = document.getElementById('btnPlay');
            const isHidden = h.style.display === 'none';
            h.style.display = isHidden ? 'block' : 'none';
            r.style.display = isHidden ? 'block' : 'none';
            btn.style.display = isHidden ? 'none' : 'inline-flex';
        },

        startAutoCheck: function () {
            if (this.autoCheckTimer) clearTimeout(this.autoCheckTimer);
            this.autoCheckTimer = setTimeout(() => {
                if (document.getElementById('feedbackOverlay').style.display === 'none') {
                    this.checkAnswer();
                }
            }, 1200);
        },

        cancelAutoCheck: function () {
            if (this.autoCheckTimer) {
                clearTimeout(this.autoCheckTimer);
                this.autoCheckTimer = null;
            }
        },

        checkAnswer: async function () {
            if (!this.session || sketch.isEmpty()) return;
            const canvas = document.getElementById('drawingBoard');
            const inputTensor = this.processCanvasForONNX(canvas);
            if (!inputTensor) return;

            try {
                const feeds = {input: inputTensor};
                const results = await this.session.run(feeds);
                const outputData = results.output.data;
                let maxVal = -Infinity, maxIdx = -1;
                for (let i = 0; i < outputData.length; i++) {
                    if (outputData[i] > maxVal) { maxVal = outputData[i]; maxIdx = i; }
                }
                const aiChar = MODEL_LABELS[maxIdx];
                const mapFix = {"ta": "ãŸ", "te": "ã¦", "ha": "ã¯", "he": "ã¸", "ho": "ã»"};
                const displayChar = mapFix[aiChar] || aiChar;
                this.showFeedback(displayChar, maxVal);
            } catch (e) { console.error(e); }
        },

        showFeedback: function (aiChar, confidence) {
            const overlay = document.getElementById('feedbackOverlay');
            const icon = document.getElementById('fbIcon');
            const title = document.getElementById('fbTitle');
            const desc = document.getElementById('fbDesc');
            overlay.style.display = 'flex';
            if (aiChar === this.currentQ.h) {
                icon.innerText = 'ğŸ‰';
                title.innerText = 'ç­”å°äº†ï¼';
                title.style.color = '#2e7d32';
                desc.innerText = `AI çœ‹åˆ°ï¼š${aiChar} (${confidence.toFixed(1)})`;
                this.streak++;
                setTimeout(() => this.playAudio(), 200);
            } else {
                icon.innerText = 'ğŸ¤”';
                title.innerText = 'å—¯...ä¸å¤ªåƒï¼Ÿ';
                title.style.color = '#c62828';
                desc.innerText = `é¡Œç›®æ˜¯ã€Œ${this.currentQ.h}ã€ï¼ŒAI çœ‹åˆ°ã€Œ${aiChar}ã€`;
                this.streak = 0;
            }
            document.getElementById('streakCount').innerText = this.streak;
        },

        forceCorrect: function () {
            this.handleSaveAction();
            this.streak++;
            document.getElementById('streakCount').innerText = this.streak;
            document.getElementById('fbTitle').innerText = "å·²å›å ±ï¼";
            setTimeout(() => this.nextQuestion(), 1500);
        },

        markAsWrong: function () {
            this.streak = 0;
            document.getElementById('streakCount').innerText = 0;
            this.nextQuestion();
        },

        handleSaveAction: function() {
            const canvas = document.getElementById('drawingBoard');
            // å–å¾—è™•ç†éå¾Œçš„ 64x64 å½±åƒ (ç¢ºä¿æ˜¯é»‘åº•ç™½å­—)
            const processed = processCanvasForAI(canvas, 64);
            if (!processed) return;

            const dataUrl = processed.toDataURL("image/png");
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                const modal = document.getElementById('saveModal');
                const img = document.getElementById('saveImageDisplay');
                img.src = dataUrl;
                modal.style.display = 'flex';
            } else {
                const link = document.createElement('a');
                link.download = `${this.currentQ.r}_${Date.now()}.png`;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        },

        processCanvasForONNX: function (sourceCanvas) {
            const processedCanvas = processCanvasForAI(sourceCanvas, 64);
            if (!processedCanvas) return null;
            const ctx = processedCanvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, 64, 64);
            const {data} = imgData;
            const floatData = new Float32Array(3 * 64 * 64);

            // é€™è£¡ç›´æ¥è®€å–è™•ç†å¥½çš„å½±åƒ (å·²ç¶“æ˜¯é»‘åº•ç™½å­—)ï¼Œä¸ç”¨å†è™•ç†
            for (let i = 0; i < 64 * 64; i++) {
                // å› ç‚º processCanvasForAI å·²ç¶“ç¢ºä¿æ˜¯é»‘åº•ç™½å­—ï¼Œæ‰€ä»¥ç›´æ¥å–ç´…è‰²é€šé“å³å¯
                // é»‘è‰²=0ï¼Œç™½è‰²=255ï¼Œæ­¸ä¸€åŒ–æˆ 0.0 ~ 1.0
                const r = data[i * 4] / 255.0;
                floatData[i] = r;
                floatData[64 * 64 + i] = r;
                floatData[2 * 64 * 64 + i] = r;
            }
            return new ort.Tensor('float32', floatData, [1, 3, 64, 64]);
        }
    };

    // â˜…â˜…â˜… é‡å¯«çš„æ ¸å¿ƒï¼šç¢ºä¿æ­£æ–¹å½¢èˆ‡é¡è‰²æ­£ç¢ºåè½‰ â˜…â˜…â˜…
    function processCanvasForAI(sourceCanvas, targetSize = 64) {
        const ctx = sourceCanvas.getContext('2d');
        const width = sourceCanvas.width;
        const height = sourceCanvas.height;
        const imgData = ctx.getImageData(0, 0, width, height);
        const data = imgData.data;

        // 1. å°‹æ‰¾é‚Šç•Œ (ç™½åº•é»‘å­—ï¼Œæ‰€ä»¥æ‰¾ < 250 çš„é»)
        let minX = width, minY = height, maxX = 0, maxY = 0, found = false;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                // å°‹æ‰¾é»‘è‰²ç­†è·¡ (å‡è¨­ç­†è·¡å¤ é»‘)
                if (data[(y * width + x) * 4] < 200) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    found = true;
                }
            }
        }
        if (!found) return null; // ç©ºç™½ç•«å¸ƒ

        // 2. è¨ˆç®—è£å‰ªå€åŸŸ
        const cropW = maxX - minX + 1;
        const cropH = maxY - minY + 1;

        // 3. è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ (ä¿æŒé•·å¯¬æ¯”)
        // é ç•™ 10px padding è®“å­—ä¸è¦é ‚åˆ°é‚Š
        const padding = 10;
        const scale = Math.min((targetSize - padding) / cropW, (targetSize - padding) / cropH);
        const sw = Math.floor(cropW * scale);
        const sh = Math.floor(cropH * scale);

        // 4. è¨ˆç®—ç½®ä¸­ä½ç½®
        const dx = Math.floor((targetSize - sw) / 2);
        const dy = Math.floor((targetSize - sh) / 2);

        // 5. å»ºç«‹ç›®æ¨™ç•«å¸ƒ (64x64)
        const finalC = document.createElement('canvas');
        finalC.width = targetSize;
        finalC.height = targetSize;
        const fCtx = finalC.getContext('2d');

        // 6. â˜…é—œéµä¿®æ”¹ï¼šä¸ä½¿ç”¨ CSS filterï¼Œæ”¹ç”¨æ‰‹å‹•åƒç´ æ¬é‹â˜…
        // é€™æ¨£å¯ä»¥ç¢ºä¿æ‰‹æ©Ÿä¸Šä¹Ÿä¸€å®šæ˜¯é»‘åº•ç™½å­—

        // å…ˆå¡«æ»¿å…¨é»‘ (AI éœ€è¦é»‘åº•)
        fCtx.fillStyle = "black";
        fCtx.fillRect(0, 0, targetSize, targetSize);

        // æš«æ™‚ç•«å¸ƒå­˜è£å‰ªä¸‹çš„åŸåœ– (ç™½åº•é»‘å­—)
        const tempC = document.createElement('canvas');
        tempC.width = cropW;
        tempC.height = cropH;
        const tCtx = tempC.getContext('2d');
        tCtx.drawImage(sourceCanvas, minX, minY, cropW, cropH, 0, 0, cropW, cropH);

        // ç¸®æ”¾ç•«åˆ°å¦ä¸€å€‹æš«å­˜ (ç¸®æ”¾å¾Œçš„ç™½åº•é»‘å­—)
        const scaledC = document.createElement('canvas');
        scaledC.width = targetSize;
        scaledC.height = targetSize;
        const sCtx = scaledC.getContext('2d');
        // å¡«ç™½åº•
        sCtx.fillStyle = "white";
        sCtx.fillRect(0, 0, targetSize, targetSize);
        // ç•«ä¸Šç¸®æ”¾å¾Œçš„å­—
        sCtx.drawImage(tempC, 0, 0, cropW, cropH, dx, dy, sw, sh);

        // 7. æ‰‹å‹•åè½‰é¡è‰² (ç¢ºä¿ç›¸å®¹æ€§)
        const sData = sCtx.getImageData(0, 0, targetSize, targetSize);
        const pixels = sData.data;
        for(let i=0; i < pixels.length; i+=4) {
            // åŸæœ¬: ç™½åº•(255)é»‘å­—(0)
            // ç›®æ¨™: é»‘åº•(0)ç™½å­—(255)

            // ç°¡å–®åè½‰ç®—æ³•: 255 - åŸå€¼
            // åŠ ä¸ŠäºŒå€¼åŒ–å¢å¼·å°æ¯” (Thresholding)
            const val = pixels[i]; // å– R é€šé“å³å¯ (é»‘ç™½åœ–)

            // å¦‚æœåŸæœ¬æ˜¯äº®(èƒŒæ™¯)ï¼Œè®Šé»‘(0)ï¼›å¦‚æœåŸæœ¬æ˜¯æš—(ç­†è·¡)ï¼Œè®Šç™½(255)
            const newVal = val > 150 ? 0 : 255;

            pixels[i] = newVal;     // R
            pixels[i+1] = newVal;   // G
            pixels[i+2] = newVal;   // B
            pixels[i+3] = 255;      // Alpha å›ºå®šä¸é€æ˜
        }

        // å°‡è™•ç†å¾Œçš„åƒç´ æ”¾å›æœ€çµ‚ç•«å¸ƒ
        fCtx.putImageData(sData, 0, 0);

        return finalC;
    }

    const sketch = {
        init: function () {
            this.c = document.getElementById('drawingBoard');
            this.ctx = this.c.getContext('2d', {willReadFrequently: true});
            const wrapper = this.c.parentElement;

            // â˜…é—œéµä¿®æ”¹ï¼šå¼·åˆ¶è®“ç•«å¸ƒå…§éƒ¨è§£æåº¦ç‚ºæ­£æ–¹å½¢ (å–è¼ƒçŸ­é‚Š)â˜…
            // é€™æ¨£å³ä½¿ CSS å› ç‚ºç¶²å€åˆ—è¢«æ‹‰é•·ï¼Œç•«å¸ƒå…§å®¹åº§æ¨™é‚„æ˜¯ 1:1
            const size = Math.min(wrapper.clientWidth, wrapper.clientHeight);

            // æˆ–è€…ï¼Œæ›´ç°¡å–®çš„ï¼Œæˆ‘å€‘è®“ canvas è§£æåº¦è·Ÿéš¨å¯¬åº¦ (å› ç‚ºå¯¬åº¦é€šå¸¸ä¸è®Š)
            // é«˜åº¦è‹¥æœ‰è®Šï¼ŒCSS aspect-ratio:1 æœƒæ§åˆ¶é¡¯ç¤ºï¼Œä½†å…§éƒ¨åƒç´ æˆ‘å€‘è¨­ç‚ºä¸€æ¨£
            this.c.width = wrapper.clientWidth;
            this.c.height = wrapper.clientWidth; // å¼·åˆ¶æ­£æ–¹å½¢è§£æåº¦

            this.clear();
            const start = (e) => {
                if (e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                this.draw = true;
                this.ctx.beginPath();
                const p = this.pos(e);
                this.ctx.moveTo(p.x, p.y);
                app.cancelAutoCheck();
            };
            const move = (e) => {
                if (e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                if (this.draw) {
                    const p = this.pos(e);
                    this.ctx.lineTo(p.x, p.y);
                    this.ctx.stroke();
                }
            };
            const end = () => {
                this.draw = false;
                app.startAutoCheck();
            };
            this.c.addEventListener('mousedown', start);
            this.c.addEventListener('mousemove', move);
            this.c.addEventListener('mouseup', end);
            this.c.addEventListener('touchstart', start, {passive: false});
            this.c.addEventListener('touchmove', move, {passive: false});
            this.c.addEventListener('touchend', end);

            // è¦–çª—æ”¹è®Šå¤§å°æ™‚é‡æ–°èª¿æ•´
            window.addEventListener('resize', () => {
                this.c.width = wrapper.clientWidth;
                this.c.height = wrapper.clientWidth; // ä¿æŒæ­£æ–¹å½¢
                this.clear();
            });
        },
        pos: function (e) {
            const r = this.c.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // å› ç‚ºæˆ‘å€‘å¼·åˆ¶ canvas è§£æåº¦èˆ‡ CSS é¡¯ç¤ºå°ºå¯¸å¯èƒ½ä¸åŒ (å¦‚æœè¢«æ‹‰ä¼¸)
            // æ‰€ä»¥è¦é€²è¡Œåº§æ¨™è½‰æ›
            const scaleX = this.c.width / r.width;
            const scaleY = this.c.height / r.height;

            return {
                x: (clientX - r.left) * scaleX,
                y: (clientY - r.top) * scaleY
            };
        },
        clear: function () {
            this.ctx.fillStyle = "white";
            this.ctx.fillRect(0, 0, this.c.width, this.c.height);
            this.ctx.lineWidth = 15; // ç¨å¾®åŠ ç²—ä¸€é»ï¼Œæ‰‹æ©Ÿä¸Šå¯«å­—æ¯”è¼ƒæ¸…æ¥š
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.strokeStyle = 'black';
            app.cancelAutoCheck();
        },
        isEmpty: function () {
            const d = this.ctx.getImageData(0, 0, this.c.width, this.c.height).data;
            for (let i = 0; i < d.length; i += 4) if (d[i] < 255) return false;
            return true;
        }
    };

    document.addEventListener("DOMContentLoaded", () => app.init());
</script>
</body>
</html>