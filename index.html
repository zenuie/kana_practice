<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è½å¯«ç‰¹è¨“</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

    <style>
        body {
            font-family: "Noto Sans JP", "Hiragino Kaku Gothic ProN", sans-serif;
            background-color: #f4f7f6;
            touch-action: none;
            user-select: none;
            overflow: hidden;
        }

        #startOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.98); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center;
        }

        /* å½ˆçª—æ¨£å¼ */
        #saveModal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 10000;
            display: none;
            flex-direction: column; justify-content: center; align-items: center;
        }

        /* åœ–ç‰‡é¡¯ç¤ºå€ï¼šåŠ ä¸Šç™½è‰²é‚Šæ¡†ï¼Œå› ç‚ºåœ–ç‰‡æœ¬èº«æ˜¯é»‘åº•ï¼Œæ€•è·ŸèƒŒæ™¯èç‚ºä¸€é«” */
        #saveImageDisplay {
            background: black;
            border: 4px solid #fff; /* ç™½è‰²é‚Šæ¡† */
            border-radius: 16px;
            width: 250px;
            height: 250px;
            object-fit: contain;
            box-shadow: 0 0 30px rgba(255,255,255,0.2);
            image-rendering: pixelated; /* è®“é»‘ç™½åƒç´ åˆ†æ˜ */
        }

        .top-bar {
            background: white; padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            display: flex; justify-content: space-between; align-items: center;
        }

        .learning-card {
            background: white; border-radius: 24px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            overflow: hidden; max-width: 400px; margin: 20px auto;
            position: relative;
        }

        .question-area {
            padding: 20px; text-align: center; background: #e3f2fd; position: relative;
        }

        .speaker-btn {
            width: 90px; height: 90px; background: #2196f3;
            border-radius: 50%; color: white; font-size: 40px;
            border: none; box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
            transition: transform 0.1s; display: inline-flex;
            align-items: center; justify-content: center; cursor: pointer;
        }
        .speaker-btn:active { transform: scale(0.95); }

        .hint-text {
            font-size: 6rem; font-weight: bold; color: #1565c0;
            display: none; animation: fadeIn 0.3s;
        }
        .romaji-hint {
            font-size: 1.2rem; color: #666; margin-top: 10px; display: none;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1; /* å¼·åˆ¶ CSS æ­£æ–¹å½¢ */
            background: #fff;
            cursor: crosshair;
            border-top: 2px dashed #e0e0e0;
            border-bottom: 2px dashed #e0e0e0;
        }
        canvas { width: 100%; height: 100%; display: block; }

        .controls { padding: 20px; display: flex; flex-direction: column; gap: 10px; }

        .btn-action { padding: 15px; border-radius: 12px; font-size: 1.1rem; font-weight: bold; border: none; transition: all 0.2s; }
        .btn-check { background: #4caf50; color: white; box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3); }
        .btn-check:active { transform: translateY(2px); }

        .tools-row { display: flex; gap: 10px; }
        .btn-tool { flex: 1; background: #f5f5f5; color: #555; }

        .feedback-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.95); z-index: 10;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; animation: slideUp 0.3s ease-out;
        }

        .result-icon { font-size: 80px; margin-bottom: 10px; }
        .result-title { font-size: 24px; font-weight: bold; margin-bottom: 5px; }
        .result-desc { color: #666; margin-bottom: 20px; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body>

<div id="startOverlay">
    <div class="mb-4" style="font-size: 3rem;">ğŸŒ</div>
    <h1 class="mb-4 text-primary fw-bold">è½å¯«ç‰¹è¨“</h1>
    <div class="px-4">
        <p class="text-muted mb-4">è«‹é–‹å•ŸéŸ³é‡ï¼Œé»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å§‹</p>
        <button class="btn btn-primary btn-lg px-5 py-3 rounded-pill shadow fw-bold" onclick="app.unlockAudio()">
            â–¶ï¸ é–‹å§‹ç·´ç¿’
        </button>
    </div>
</div>

<!-- åœ–ç‰‡å„²å­˜å½ˆçª— -->
<div id="saveModal" onclick="this.style.display='none'">
    <h3 class="text-white mb-3">é•·æŒ‰åœ–ç‰‡åŠ å…¥ç…§ç‰‡</h3>
    <img id="saveImageDisplay" src="" alt="Sample">
    <p class="text-white-50 mt-3 small">å·²è½‰ç‚ºé»‘åº•ç™½å­—æ­£æ–¹å½¢æ ¼å¼</p>
</div>

<div class="top-bar">
    <div class="fw-bold text-primary">ğŸŒ è½å¯«ç‰¹è¨“</div>
    <div class="d-flex gap-2 align-items-center">
        <span id="statusBadge" class="badge bg-secondary">è¼‰å…¥ AI...</span>
        <span class="badge bg-light text-dark border">é€£å°: <span id="streakCount">0</span></span>
    </div>
</div>

<div class="learning-card">
    <div class="question-area">
        <button class="speaker-btn" id="btnPlay" onclick="app.playAudio()">ğŸ”Š</button>
        <div id="visualHint" class="hint-text">ã‚</div>
        <div id="romajiHint" class="romaji-hint">a</div>
        <div class="mt-3">
            <button class="btn btn-sm btn-link text-decoration-none" onclick="app.toggleHint()">ğŸ’¡ å·çœ‹æç¤º</button>
        </div>
    </div>

    <div class="canvas-container">
        <div class="grid-line grid-h"></div>
        <div class="grid-line grid-v"></div>
        <canvas id="drawingBoard"></canvas>
    </div>

    <div class="controls">
        <button class="btn-action btn-check" onclick="app.checkAnswer()">âœ¨ æª¢æŸ¥ç­”æ¡ˆ</button>
        <div class="tools-row">
            <button class="btn-action btn-tool" onclick="sketch.clear()">ğŸ—‘ï¸ æ¸…é™¤</button>
            <button class="btn-action btn-tool" onclick="app.nextQuestion()">â© è·³é</button>
        </div>
    </div>

    <div id="feedbackOverlay" class="feedback-overlay">
        <div id="fbIcon" class="result-icon">ğŸ‰</div>
        <div id="fbTitle" class="result-title">ç­”å°äº†ï¼</div>
        <div id="fbDesc" class="result-desc">AI çœ‹åˆ°ï¼šã‚ (99%)</div>

        <div class="d-grid gap-2 w-75">
            <button class="btn btn-primary btn-lg rounded-pill shadow" onclick="app.nextQuestion()">ä¸‹ä¸€é¡Œ â”</button>
            <div class="border-top pt-3 mt-2">
                <small class="text-muted d-block mb-2">AI åˆ¤æ–·éŒ¯äº†å—ï¼Ÿ</small>
                <button class="btn btn-outline-danger btn-sm w-100" onclick="app.markAsWrong()">âŒ å…¶å¯¦æˆ‘å¯«éŒ¯äº†</button>
                <button class="btn btn-outline-success btn-sm w-100 mt-2" onclick="app.forceCorrect()">â­• å…¶å¯¦æˆ‘æ˜¯å°çš„ (å­˜åœ–)</button>
            </div>
        </div>
    </div>
</div>

<script>
    const KANA_DB = [
        {r: 'a', h: 'ã‚'}, {r: 'i', h: 'ã„'}, {r: 'u', h: 'ã†'}, {r: 'e', h: 'ãˆ'}, {r: 'o', h: 'ãŠ'},
        {r: 'ka', h: 'ã‹'}, {r: 'ki', h: 'ã'}, {r: 'ku', h: 'ã'}, {r: 'ke', h: 'ã‘'}, {r: 'ko', h: 'ã“'},
        {r: 'sa', h: 'ã•'}, {r: 'shi', h: 'ã—'}, {r: 'su', h: 'ã™'}, {r: 'se', h: 'ã›'}, {r: 'so', h: 'ã'},
        {r: 'ta', h: 'ãŸ'}, {r: 'chi', h: 'ã¡'}, {r: 'tsu', h: 'ã¤'}, {r: 'te', h: 'ã¦'}, {r: 'to', h: 'ã¨'},
        {r: 'na', h: 'ãª'}, {r: 'ni', h: 'ã«'}, {r: 'nu', h: 'ã¬'}, {r: 'ne', h: 'ã­'}, {r: 'no', h: 'ã®'},
        {r: 'ha', h: 'ã¯'}, {r: 'hi', h: 'ã²'}, {r: 'fu', h: 'ãµ'}, {r: 'he', h: 'ã¸'}, {r: 'ho', h: 'ã»'},
        {r: 'ma', h: 'ã¾'}, {r: 'mi', h: 'ã¿'}, {r: 'mu', h: 'ã‚€'}, {r: 'me', h: 'ã‚'}, {r: 'mo', h: 'ã‚‚'},
        {r: 'ya', h: 'ã‚„'}, {r: 'yu', h: 'ã‚†'}, {r: 'yo', h: 'ã‚ˆ'},
        {r: 'ra', h: 'ã‚‰'}, {r: 'ri', h: 'ã‚Š'}, {r: 'ru', h: 'ã‚‹'}, {r: 're', h: 'ã‚Œ'}, {r: 'ro', h: 'ã‚'},
        {r: 'wa', h: 'ã‚'}, {r: 'wo', h: 'ã‚’'}, {r: 'n', h: 'ã‚“'}
    ];

    let MODEL_LABELS = [];

    const app = {
        session: null,
        currentQ: null,
        streak: 0,
        autoCheckTimer: null,
        isAudioUnlocked: false,

        init: async function () {
            sketch.init();
            if ('speechSynthesis' in window) window.speechSynthesis.getVoices();
            await this.loadLabels();
            await this.initAI();
        },

        unlockAudio: function() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                osc.connect(ctx.destination);
                osc.start(0);
                osc.stop(0.01);
            }
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const u = new SpeechSynthesisUtterance('');
                window.speechSynthesis.speak(u);
            }
            this.isAudioUnlocked = true;
            document.getElementById('startOverlay').style.display = 'none';
            this.nextQuestion();
        },

        loadLabels: async function () {
            try {
                const res = await fetch('./data/labels.json');
                if (res.ok) MODEL_LABELS = await res.json();
            } catch (e) { console.warn("Labels error", e); }
        },

        initAI: async function () {
            try {
                const option = {executionProviders: ['wasm']};
                this.session = await ort.InferenceSession.create('./onnx_model/hiragana.onnx', option);
                document.getElementById('statusBadge').className = 'badge bg-success';
                document.getElementById('statusBadge').innerText = 'AI å°±ç·’';
            } catch (e) {
                document.getElementById('statusBadge').className = 'badge bg-danger';
                document.getElementById('statusBadge').innerText = 'AI å¤±æ•—';
            }
        },

        nextQuestion: function () {
            document.getElementById('feedbackOverlay').style.display = 'none';
            this.currentQ = KANA_DB[Math.floor(Math.random() * KANA_DB.length)];
            document.getElementById('visualHint').style.display = 'none';
            document.getElementById('visualHint').innerText = this.currentQ.h;
            document.getElementById('romajiHint').style.display = 'none';
            document.getElementById('romajiHint').innerText = this.currentQ.r;
            document.getElementById('btnPlay').style.display = 'inline-flex';
            sketch.clear();
            if (this.isAudioUnlocked) setTimeout(() => this.playAudio(), 500);
        },

        playAudio: function () {
            if (!this.currentQ) return;
            const char = this.currentQ.h;
            const audioUrl = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=ja&q=${encodeURIComponent(char)}`;
            const audio = new Audio(audioUrl);
            audio.play().catch(e => this.playFallbackAudio(char));
        },

        playFallbackAudio: function (text) {
            if (!('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'ja-JP';
            u.rate = 0.8;
            const voices = window.speechSynthesis.getVoices();
            const preferredVoice = voices.find(v => v.lang === 'ja-JP' && (v.name.includes("Kyoko") || v.name.includes("Otoya")));
            if (preferredVoice) u.voice = preferredVoice;
            window.speechSynthesis.speak(u);
            if (window.speechSynthesis.paused) window.speechSynthesis.resume();
        },

        toggleHint: function () {
            const h = document.getElementById('visualHint');
            const r = document.getElementById('romajiHint');
            const btn = document.getElementById('btnPlay');
            const isHidden = h.style.display === 'none';
            h.style.display = isHidden ? 'block' : 'none';
            r.style.display = isHidden ? 'block' : 'none';
            btn.style.display = isHidden ? 'none' : 'inline-flex';
        },

        startAutoCheck: function () {
            if (this.autoCheckTimer) clearTimeout(this.autoCheckTimer);
            this.autoCheckTimer = setTimeout(() => {
                if (document.getElementById('feedbackOverlay').style.display === 'none') {
                    this.checkAnswer();
                }
            }, 1200);
        },

        cancelAutoCheck: function () {
            if (this.autoCheckTimer) {
                clearTimeout(this.autoCheckTimer);
                this.autoCheckTimer = null;
            }
        },

        checkAnswer: async function () {
            if (!this.session || sketch.isEmpty()) return;
            const canvas = document.getElementById('drawingBoard');
            // AI ç”¨çš„ (64px, é»‘åº•ç™½å­—)
            const inputTensor = this.processCanvasForONNX(canvas);
            if (!inputTensor) return;

            try {
                const feeds = {input: inputTensor};
                const results = await this.session.run(feeds);
                const outputData = results.output.data;
                let maxVal = -Infinity, maxIdx = -1;
                for (let i = 0; i < outputData.length; i++) {
                    if (outputData[i] > maxVal) { maxVal = outputData[i]; maxIdx = i; }
                }
                const aiChar = MODEL_LABELS[maxIdx];
                const mapFix = {"ta": "ãŸ", "te": "ã¦", "ha": "ã¯", "he": "ã¸", "ho": "ã»"};
                const displayChar = mapFix[aiChar] || aiChar;
                this.showFeedback(displayChar, maxVal);
            } catch (e) { console.error(e); }
        },

        showFeedback: function (aiChar, confidence) {
            const overlay = document.getElementById('feedbackOverlay');
            const icon = document.getElementById('fbIcon');
            const title = document.getElementById('fbTitle');
            const desc = document.getElementById('fbDesc');
            overlay.style.display = 'flex';
            if (aiChar === this.currentQ.h) {
                icon.innerText = 'ğŸ‰';
                title.innerText = 'ç­”å°äº†ï¼';
                title.style.color = '#2e7d32';
                desc.innerText = `AI çœ‹åˆ°ï¼š${aiChar} (${confidence.toFixed(1)})`;
                this.streak++;
                setTimeout(() => this.playAudio(), 200);
            } else {
                icon.innerText = 'ğŸ¤”';
                title.innerText = 'å—¯...ä¸å¤ªåƒï¼Ÿ';
                title.style.color = '#c62828';
                desc.innerText = `é¡Œç›®æ˜¯ã€Œ${this.currentQ.h}ã€ï¼ŒAI çœ‹åˆ°ã€Œ${aiChar}ã€`;
                this.streak = 0;
            }
            document.getElementById('streakCount').innerText = this.streak;
        },

        forceCorrect: function () {
            this.handleSaveAction();
            this.streak++;
            document.getElementById('streakCount').innerText = this.streak;
            document.getElementById('fbTitle').innerText = "å·²å›å ±ï¼";
            setTimeout(() => this.nextQuestion(), 1500);
        },

        markAsWrong: function () {
            this.streak = 0;
            document.getElementById('streakCount').innerText = 0;
            this.nextQuestion();
        },

        handleSaveAction: function() {
            const canvas = document.getElementById('drawingBoard');
            // â˜… é‡é»ä¿®æ­£ï¼šé€™è£¡ç”¢ç”Ÿçš„åœ–ç‰‡è¦æ˜¯ã€Œé»‘åº•ç™½å­—ã€ä¸”ã€Œæ­£æ–¹å½¢ã€
            const readableImage = createBlackBgImage(canvas, 300);

            if (!readableImage) return;

            const dataUrl = readableImage.toDataURL("image/png");
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                const modal = document.getElementById('saveModal');
                const img = document.getElementById('saveImageDisplay');
                img.src = dataUrl;
                modal.style.display = 'flex';
            } else {
                const link = document.createElement('a');
                link.download = `${this.currentQ.r}_${Date.now()}.png`;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        },

        processCanvasForONNX: function (sourceCanvas) {
            // çµ¦ AI çš„ä¹Ÿæ˜¯ 64px é»‘åº•ç™½å­— (å¾©ç”¨åŒæ¨£é‚è¼¯)
            const processedCanvas = createBlackBgImage(sourceCanvas, 64);
            if (!processedCanvas) return null;
            const ctx = processedCanvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, 64, 64);
            const {data} = imgData;
            const floatData = new Float32Array(3 * 64 * 64);
            for (let i = 0; i < 64 * 64; i++) {
                const r = data[i * 4] / 255.0; // 0=é»‘, 1=ç™½
                floatData[i] = r;
                floatData[64 * 64 + i] = r;
                floatData[2 * 64 * 64 + i] = r;
            }
            return new ort.Tensor('float32', floatData, [1, 3, 64, 64]);
        }
    };

    // â˜… çµ‚æ¥µæ ¸å¿ƒå‡½å¼ï¼šç”¢ç”Ÿé»‘åº•ç™½å­—çš„æ­£æ–¹å½¢åœ–ç‰‡ â˜…
    // æ­¤å‡½å¼åŒæ™‚çµ¦ AI (64px) å’Œ äººé¡å­˜æª” (300px) ä½¿ç”¨ï¼Œç¢ºä¿ä¸€è‡´
    function createBlackBgImage(sourceCanvas, targetSize = 300) {
        const ctx = sourceCanvas.getContext('2d');
        const width = sourceCanvas.width;
        const height = sourceCanvas.height;
        const imgData = ctx.getImageData(0, 0, width, height);
        const data = imgData.data;

        // 1. è£åˆ‡ï¼šå°‹æ‰¾ç­†è·¡é‚Šç•Œ
        let minX = width, minY = height, maxX = 0, maxY = 0, found = false;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                // åŸå§‹ç•«å¸ƒæ˜¯ç™½åº•(255) é»‘ç­†(<200)
                if (data[(y * width + x) * 4] < 200) {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    found = true;
                }
            }
        }
        if (!found) return null;

        const cropW = maxX - minX + 1;
        const cropH = maxY - minY + 1;
        const padding = Math.floor(targetSize * 0.1); // 10% ç•™ç™½

        // 2. è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
        const scale = Math.min((targetSize - padding * 2) / cropW, (targetSize - padding * 2) / cropH);
        const sw = Math.floor(cropW * scale);
        const sh = Math.floor(cropH * scale);
        const dx = Math.floor((targetSize - sw) / 2);
        const dy = Math.floor((targetSize - sh) / 2);

        // 3. å»ºç«‹æœ€çµ‚ç•«å¸ƒ (é»‘åº•)
        const finalC = document.createElement('canvas');
        finalC.width = targetSize;
        finalC.height = targetSize;
        const fCtx = finalC.getContext('2d');

        // å¡«æ»¿é»‘è‰²
        fCtx.fillStyle = "black";
        fCtx.fillRect(0, 0, targetSize, targetSize);

        // 4. ç¸®æ”¾èˆ‡ç¹ªè£½ (å…ˆç•«åœ¨ä¸€å¼µç™½åº•çš„æš«å­˜ä¸Šï¼Œæ–¹ä¾¿åšåƒç´ è™•ç†)
        const tempC = document.createElement('canvas');
        tempC.width = targetSize;
        tempC.height = targetSize;
        const tCtx = tempC.getContext('2d');

        tCtx.fillStyle = "white"; // æš«å­˜åº•è‰²ç‚ºç™½
        tCtx.fillRect(0, 0, targetSize, targetSize);
        // ç•«ä¸Šç¸®æ”¾å¾Œçš„å­— (é€™æ™‚å€™é‚„æ˜¯é»‘è‰²ç­†è·¡)
        tCtx.drawImage(sourceCanvas, minX, minY, cropW, cropH, dx, dy, sw, sh);

        // 5. â˜… åƒç´ é¡è‰²åè½‰ â˜…
        // æˆ‘å€‘éœ€è¦æŠŠ ç™½åº•é»‘å­— è½‰æˆ é»‘åº•ç™½å­—
        const tData = tCtx.getImageData(0, 0, targetSize, targetSize);
        const pixels = tData.data;

        for(let i=0; i < pixels.length; i+=4) {
            // åŸå§‹ï¼šç­†è·¡æ˜¯é»‘ (0)ï¼ŒèƒŒæ™¯æ˜¯ç™½ (255)
            // ç›®æ¨™ï¼šç­†è·¡æ˜¯ç™½ (255)ï¼ŒèƒŒæ™¯æ˜¯é»‘ (0)
            const val = pixels[i]; // å– R é€šé“

            // ç°¡å–®åè½‰ï¼šå¦‚æœæ˜¯äº®çš„(èƒŒæ™¯)ï¼Œè®Šå…¨é»‘(0)ï¼›å¦‚æœæ˜¯æš—çš„(ç­†è·¡)ï¼Œè®Šå…¨ç™½(255)
            const newVal = val > 128 ? 0 : 255;

            pixels[i] = newVal;     // R
            pixels[i+1] = newVal;   // G
            pixels[i+2] = newVal;   // B
            pixels[i+3] = 255;      // Alpha
        }

        // å°‡åè½‰å¾Œçš„åƒç´ æ”¾åˆ°æœ€çµ‚çš„é»‘åº•ç•«å¸ƒä¸Š
        fCtx.putImageData(tData, 0, 0);

        return finalC;
    }

    const sketch = {
        init: function () {
            this.c = document.getElementById('drawingBoard');
            this.ctx = this.c.getContext('2d', {willReadFrequently: true});
            const wrapper = this.c.parentElement;
            // å¼·åˆ¶ç•«å¸ƒå…§éƒ¨è§£æåº¦ç‚ºæ­£æ–¹å½¢ (é¿å…æ‰‹æ©Ÿç¶²å€åˆ—ä¼¸ç¸®å°è‡´é•·æ–¹å½¢)
            this.c.width = wrapper.clientWidth;
            this.c.height = wrapper.clientWidth;
            this.clear();

            const start = (e) => {
                if (e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                this.draw = true;
                this.ctx.beginPath();
                const p = this.pos(e);
                this.ctx.moveTo(p.x, p.y);
                app.cancelAutoCheck();
            };
            const move = (e) => {
                if (e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                if (this.draw) {
                    const p = this.pos(e);
                    this.ctx.lineTo(p.x, p.y);
                    this.ctx.stroke();
                }
            };
            const end = () => {
                this.draw = false;
                app.startAutoCheck();
            };
            this.c.addEventListener('mousedown', start);
            this.c.addEventListener('mousemove', move);
            this.c.addEventListener('mouseup', end);
            this.c.addEventListener('touchstart', start, {passive: false});
            this.c.addEventListener('touchmove', move, {passive: false});
            this.c.addEventListener('touchend', end);

            window.addEventListener('resize', () => {
                this.c.width = wrapper.clientWidth;
                this.c.height = wrapper.clientWidth;
                this.clear();
            });
        },
        pos: function (e) {
            const r = this.c.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            // åº§æ¨™è½‰æ› (CSS å°ºå¯¸ -> Canvas åƒç´ )
            const scaleX = this.c.width / r.width;
            const scaleY = this.c.height / r.height;
            return {
                x: (clientX - r.left) * scaleX,
                y: (clientY - r.top) * scaleY
            };
        },
        clear: function () {
            this.ctx.fillStyle = "white";
            this.ctx.fillRect(0, 0, this.c.width, this.c.height);
            this.ctx.lineWidth = 15;
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.strokeStyle = 'black';
            app.cancelAutoCheck();
        },
        isEmpty: function () {
            const d = this.ctx.getImageData(0, 0, this.c.width, this.c.height).data;
            for (let i = 0; i < d.length; i += 4) if (d[i] < 255) return false;
            return true;
        }
    };

    document.addEventListener("DOMContentLoaded", () => app.init());
</script>
</body>
</html>